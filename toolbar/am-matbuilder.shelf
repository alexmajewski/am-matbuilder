<?xml version="1.0" encoding="UTF-8"?>
<shelfDocument>
  <!-- This file contains definitions of shelves, toolbars, and tools.
 It should not be hand-edited when it is being used by the application.
 Note, that two definitions of the same element are not allowed in
 a single file. -->

  <toolshelf name="am_matbuilder" label="AM Mat Builder">
    <memberTool name="am_matbuilder"/>
  </toolshelf>

  <tool name="am_matbuilder" label="Matbuilder" icon="LOP_materiallibrary">
    <script scriptType="python"><![CDATA[import hou
import os
from PySide2 import QtCore, QtUiTools, QtWidgets, QtGui
import json

__version__ = "0.2.1"
__author__ = "Alex Majewski"

lookup = {}

json_dir = hou.expandString("$AMMATBUILD/engines")
for filename in os.listdir(json_dir):

    if filename.endswith(".json"):
        with open(os.path.join(json_dir, filename), "r") as file:
            json_data = json.load(file)
            first_key = list(json_data.keys())[0]
            lookup[first_key] = json_data[first_key]

type_lookup = {
    0: "base_color",
    1: "metallness",
    2: "roughness",
    3: "normal",
    4: "displacement",
    5: "bump",
    6: "opacity",
    7: "emission"
}
# Dropdown menu indices:
opacity_index = 6


class MaterialCreator(QtWidgets.QWidget):
    def __init__(self):
        super(MaterialCreator,self).__init__()
        ui_file = hou.expandString('$AMMATBUILD/main_window.ui')
        self.ui = QtUiTools.QUiLoader().load(ui_file, parentWidget=self)
        
        layout = QtWidgets.QVBoxLayout()
        layout.setContentsMargins(0, 0, 0, 0)
        self.setLayout(layout)
        layout.addWidget(self.ui)
        
        self.resize(769,568)
        
        self.setParent(hou.ui.mainQtWindow(), QtCore.Qt.Window)
        
        self.setWindowTitle("Solaris Multi-Engine Material Builder")
        self.ui.label_author.setText(f"Created by Alex Majewski v {__version__}")
        
        self.ui.btn_addfiles.clicked.connect(self.add_files)
        self.ui.btn_gensetup.clicked.connect(self.generate_setup)
        
        self.ui.list_textures.setSelectionMode(QtWidgets.QListWidget.NoSelection)
        self.ui.list_textures.setStyleSheet("QListWidget::item:hover { background-color: none; }")
        
        self.ui.list_textures.setAcceptDrops(True)
        self.ui.list_textures.installEventFilter(self)
        
        self.paths_list = [] 
        
        self.input_index = 0
    
    def add_files(self):
        files = hou.ui.selectFile(multiple_select=True, file_type=hou.fileType.Image)
        files = files.split(" ; ")
        self.create_items_from_list(files)
                
    def create_items_from_list(self, files):
        for filepath in files:
            if filepath != "" and filepath not in self.paths_list:
                self.add_item(filepath)
                
    def eventFilter(self, source, event):
        if event.type() == QtCore.QEvent.Drop:
            if event.mimeData().hasUrls():
                if event.mimeData().hasUrls():
                    event.setDropAction(QtCore.Qt.CopyAction)
                    event.accept()
                    
                    files = []
                    
                    for url in event.mimeData().urls():
                        if url.isLocalFile():
                            files.append(str(url.toLocalFile()))
                        else:
                            files.append(str(url.toString()))
                            
                    self.create_items_from_list(files)
                else:
                    event.ignore()
            
        if event.type() == QtCore.QEvent.DragEnter:
            return True
        # elif event.type() == QtCore.QEvent.DragMove:
        #     print("Drag Move Event")
            # Handle drag move event here
            # return True
        return super(MaterialCreator, self).eventFilter(source, event)
        
    def add_item(self, filepath):
        self.paths_list.append(filepath)
        widget = List_Item_Widget(filepath)
        list_item = QtWidgets.QListWidgetItem()
        list_item.setSizeHint(QtCore.QSize(90,75))
        self.ui.list_textures.addItem(list_item)
        self.ui.list_textures.setItemWidget(list_item, widget)
    
    def info_clean(self):
        self.ui.label_info.setText("")
        self.ui.label_info.setStyleSheet("")
    
    def info_display_error(self, error_message):
        self.ui.label_info.setText(error_message)
        self.ui.label_info.setStyleSheet("color:#fc979a;")
        
    def generate_setup(self):
        self.info_clean()
    
        if self.validate_item_types() == False:
            self.info_display_error("Some textures don't have their type assigned. Aborting.")
            return
    
        network_editor = hou.ui.paneTabOfType(hou.paneTabType.NetworkEditor)
        stage = network_editor.pwd()
        
        if self.ui.cb_wipe_network.isChecked() == True:
            self.wipe_network(stage)
        
        collect = stage.createNode("collect")
        
        
        for engine in lookup.keys():
            engine_checkbox = getattr(self.ui, lookup[engine]["checkbox"], None) 
            
            if engine_checkbox.isChecked() == True:
                main_node = stage.createNode(lookup[engine]["main_node"])
                main_node.setGenericFlag(hou.nodeFlag.Material, False)
                
                last_node = main_node
           
                for intermediary_node in lookup[engine]["material_intermediary_nodes"]:
                    if intermediary_node == 'redshift::Sprite':
                        if self.ui.cb_enablerssprite.isChecked() == False:
                            continue
                        elif self.is_there_opacity_map() == False:
                            continue
                    inter_node = stage.createNode(intermediary_node)
                    inter_node.setGenericFlag(hou.nodeFlag.Material, False)
                    self.redshift_output = inter_node
                    inter_node.setInput(0, last_node)
                    last_node = inter_node
                    
                collect.setInput(self.input_index, last_node)
                self.input_index += 1
                
                    
                for index in range(self.ui.list_textures.count()):
                    widget = self.get_item_widget(index)
                    
                    type = type_lookup[widget.ui.texture_type.currentIndex()]
                    
                    file_path = widget.path
                    
                    self.create_image_node(stage, engine, collect, main_node, type, file_path)
              
        stage.layoutChildren()
        self.input_index = 0
        
    def get_item_widget(self, index):
        item = self.ui.list_textures.item(index)
        widget = self.ui.list_textures.itemWidget(item)
        return widget
                    
    def validate_item_types(self):
        for index in range(self.ui.list_textures.count()):
            item = self.ui.list_textures.item(index)
            widget = self.ui.list_textures.itemWidget(item)
            
            if widget.ui.texture_type.currentIndex() == -1:
                return False
        return True
    def is_there_opacity_map(self):
        for index in range(self.ui.list_textures.count()):
            item = self.ui.list_textures.item(index)
            widget = self.ui.list_textures.itemWidget(item)
            
            if widget.ui.texture_type.currentIndex() == opacity_index:
                return True
        return False
         
    def create_image_node(self, stage, engine, collect, main_node, type, file_path):
        img_node = stage.createNode(lookup[engine]["image_node"])
        
        img_parm = lookup[engine]["image_parms"]
        
        img_node.parm(img_parm["type"]).set(img_parm["mode"][type])
        img_node.parm(img_parm["filepath"]).set(file_path)
        
        
        if type in lookup[engine]["image_intermediary_nodes"]:
            intermediary_dict = lookup[engine]["image_intermediary_nodes"][type]
            node_to_create = intermediary_dict["node"]
            input_index = intermediary_dict["input"]
            parms_to_change = intermediary_dict["parms_to_change"]
            connect_target = intermediary_dict["target"]
            
            intermediary = stage.createNode(node_to_create)
            intermediary.setGenericFlag(hou.nodeFlag.Material, False)
            intermediary.setInput(input_index, img_node)
            intermediary.setParms(parms_to_change)
            
            if connect_target == "main_node":
                main_node.setInput(lookup[engine]["main_inputs"][type], intermediary)
            elif connect_target == "intermediary_output":
                self.redshift_output.setInput(1, intermediary)
            elif connect_target == "collect":
                collect.setInput(self.input_index, intermediary)
                self.input_index += 1
                
        else:
            main_node.setInput(lookup[engine]["main_inputs"][type], img_node)
    
    def wipe_network(self, network):
        for child_node in network.children():
            child_node.destroy()


class List_Item_Widget(QtWidgets.QWidget):
    def __init__(self, filepath, parent=None):
        super().__init__(parent)
        ui_file = hou.expandString('$AMMATBUILD/list_item.ui')
        self.ui = QtUiTools.QUiLoader().load(ui_file, parentWidget=self)
        
        layout = QtWidgets.QVBoxLayout()
        layout.setContentsMargins(0, 0, 0, 0)
        self.setLayout(layout)
        layout.addWidget(self.ui)
        
        
        self.path = filepath
        
        resolved_path = hou.expandString(filepath)
        file_name = os.path.basename(resolved_path)
        
        
        self.ui.file_path.setText(file_name)
        self.ui.file_path.setToolTip(file_name)
        
        type = self.detect_texture_type(file_name)
        self.ui.texture_type.setCurrentIndex(type)
        
        self.ui.btn_destroy.clicked.connect(self.destroy)
        
    def detect_texture_type(self, file_name):
        file_name = file_name.lower()
        
        base_color_names = ["color", "diff", "albedo"]
        opacity_names = ["opacity", "alpha", "transparency"]
        height_names = ["displace", "height"]
  
        if "nor" in file_name:
            return 3
        elif "metal" in file_name:
            return 1
        elif "rough" in file_name:
            return 2
        elif "bump" in file_name:
            return 5
        elif "emission" in file_name:
            return 7
        
        for name in base_color_names:
            if name.lower() in file_name:
                return 0
                
        for name in opacity_names:
            if name.lower() in file_name:
                return 6
                
        for name in height_names:
            if name.lower() in file_name:
                return 4
        
        
            
        return -1
        
    def destroy(self):
        list = self.parent().parent()
        items = list.findItems("", QtCore.Qt.MatchContains)
           
        for item in items:
            if list.itemWidget(item) == self:
                list.takeItem(list.row(item))
                break
        
        list.parent().parent().paths_list.remove(self.path)

        

        
    
win = MaterialCreator()
win.show()]]></script>
  </tool>
</shelfDocument>
