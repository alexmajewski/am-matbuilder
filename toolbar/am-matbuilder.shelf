<?xml version="1.0" encoding="UTF-8"?>
<shelfDocument>
  <!-- This file contains definitions of shelves, toolbars, and tools.
 It should not be hand-edited when it is being used by the application.
 Note, that two definitions of the same element are not allowed in
 a single file. -->

  <toolshelf name="am_matbuilder" label="AM Mat Builder">
    <memberTool name="am_matbuilder"/>
  </toolshelf>

  <tool name="am_matbuilder" label="Matbuilder" icon="LOP_materiallibrary">
    <script scriptType="python"><![CDATA[import hou
import os
from PySide2 import QtCore, QtUiTools, QtWidgets, QtGui
import json
import sys

__version__ = "0.2.6"
__author__ = "Alex Majewski"

lookup = {}

json_dir = hou.expandString("$AMMATBUILD/engines")
for filename in os.listdir(json_dir):

    if filename.endswith(".json"):
        with open(os.path.join(json_dir, filename), "r") as file:
            json_data = json.load(file)
            first_key = list(json_data.keys())[0]
            lookup[first_key] = json_data[first_key]
            

type_lookup = {
    0: "base_color",
    1: "metallness",
    2: "roughness",
    3: "normal",
    4: "displacement",
    5: "bump",
    6: "opacity",
    7: "emission"
}
# Dropdown menu indices:
opacity_index = 6

class MaterialCreator(QtWidgets.QWidget):
    def __init__(self):
        super(MaterialCreator,self).__init__()
        ui_file = hou.expandString('$AMMATBUILD/main_window.ui')
        self.ui = QtUiTools.QUiLoader().load(ui_file, parentWidget=self)
        
        layout = QtWidgets.QVBoxLayout()
        layout.setContentsMargins(0, 0, 0, 0)
        self.setLayout(layout)
        layout.addWidget(self.ui)
        
        self.resize(769,568)
        
        self.setParent(hou.qt.mainWindow(), QtCore.Qt.Window)
        self.setWindowFlags(QtCore.Qt.Tool)
        
        self.setWindowTitle("Solaris Multi-Engine Material Builder")
        self.ui.label_author.setText(f"Created by Alex Majewski v {__version__}")
        
        settings_path = hou.expandString("$AMMATBUILD/settings.ini")
        self.settings = QtCore.QSettings(settings_path, QtCore.QSettings.IniFormat)
        
        self.ui.btn_addfiles.clicked.connect(self.add_files)
        self.ui.btn_gensetup.clicked.connect(self.generate_setup)
        
        self.ui.list_textures.setSelectionMode(QtWidgets.QListWidget.NoSelection)
        self.ui.list_textures.setStyleSheet("QListWidget::item:hover { background-color: none; }")
        
        self.ui.list_textures.setAcceptDrops(True)
        self.ui.list_textures.installEventFilter(self)
        
        self.paths_list = [] 
        
        self.center_window()
        self.generate_engine_UI()
        self.retrieve_settings()
        
    def save_settings(self):
        self.settings.setValue(f"cb_wipe_network", self.ui.cb_wipe_network.isChecked())
    
        layouts = [self.ui.engines_layout, self.ui.engine_options_layout]
        for layout in layouts:
            for i in range(layout.count()):
                widget = layout.itemAt(i).widget()
                if isinstance(widget, QtWidgets.QCheckBox):
                    self.settings.setValue(f"{widget.objectName()}", widget.isChecked())
                    
    def retrieve_settings(self):
        if self.settings.contains("cb_wipe_network"):
            self.ui.cb_wipe_network.setChecked(self.settings.value("cb_wipe_network"))
    
        # Note: using .itemAt(i) on .ui file widgets results in a bug
        layouts = [self.ui.engines_layout, self.ui.engine_options_layout]
        for layout in layouts:
            for i in range(layout.count()):
                widget = layout.itemAt(i).widget()
                if widget is not None:
                    widget_name = layout.itemAt(i).widget().objectName()
                    if isinstance(widget, QtWidgets.QCheckBox):
                        if self.settings.contains(layout.itemAt(i).widget().objectName()):
                            layout.itemAt(i).widget().setChecked(self.settings.value(layout.itemAt(i).widget().objectName()))
                        

    def closeEvent(self, event):
        self.save_settings()
        event.accept()
    
    def generate_engine_UI(self):
        """
        Dynamically creates UI checkboxes from JSON files.
        """
        for engine in lookup:
            # create engine enabling checkbox
            checkbox_name = lookup[engine]["engine_enable_checkbox"]
            checkbox_instance = QtWidgets.QCheckBox()
            checkbox_instance.setText(engine)
            checkbox_instance.setObjectName(checkbox_name)
            checkbox_instance.setChecked(True)
            setattr(self.ui, checkbox_name, checkbox_instance)
            self.ui.engines_layout.addWidget(checkbox_instance)
            
            # create options checkboxes
            if "options_checkboxes" in lookup[engine]:
                for option in lookup[engine]["options_checkboxes"]:
                    checkbox_name = option["ui_name"]
                    checkbox_instance = QtWidgets.QCheckBox()
                    checkbox_instance.setText(option["name"])
                    checkbox_instance.setObjectName(checkbox_name)
                    checkbox_instance.setChecked(True)
                    setattr(self.ui, checkbox_name, checkbox_instance)
                    self.ui.engine_options_layout.addWidget(checkbox_instance)
        
    
    def center_window(self):
        center = hou.ui.mainQtWindow().geometry().center()
        self.move(center - self.geometry().center())
    
    def add_files(self):
        """
        Adds image files using a button.
        """
        files = hou.ui.selectFile(multiple_select=True, file_type=hou.fileType.Image)
        files = files.split(" ; ")
        self.create_items_from_list(files)
                
    def create_items_from_list(self, files):
        for filepath in files:
            if filepath != "" and filepath not in self.paths_list:
                self.add_item(filepath)
                
    def eventFilter(self, source, event):
        """
        Accepts dropping image files into the list.
        """
        if event.type() == QtCore.QEvent.Drop:
            if event.mimeData().hasUrls():
                if event.mimeData().hasUrls():
                    event.setDropAction(QtCore.Qt.CopyAction)
                    event.accept()
                    
                    files = []
                    
                    for url in event.mimeData().urls():
                        if url.isLocalFile():
                            files.append(str(url.toLocalFile()))
                        else:
                            files.append(str(url.toString()))
                            
                    self.create_items_from_list(files)
                else:
                    event.ignore()
            
        if event.type() == QtCore.QEvent.DragEnter:
            return True
        # elif event.type() == QtCore.QEvent.DragMove:
        #     print("Drag Move Event")
            # Handle drag move event here
            # return True
        return super(MaterialCreator, self).eventFilter(source, event)
        
    def update_maps(self, clicked_widget, newly_set_value):
        """
        Ensures that all textures on the list are set to a unique value.
        It's called any time a combo box value is changed.
        """
        for index in range(self.ui.list_textures.count()):
            item = self.ui.list_textures.item(index)
            item_widget = self.ui.list_textures.itemWidget(item)
            combo_box = item_widget.ui.texture_type 
            
            if item_widget != clicked_widget:
                if combo_box.currentIndex() == newly_set_value:
                    combo_box.setCurrentIndex(-1)
                else:
                    pass
            else:
                pass
        
    def add_item(self, filepath):
        """
        Adds a new item to the QListWidget,
        And creates and attaches a new List_Item_Widget to it. 
        """
        self.paths_list.append(filepath)
        
        list_item = QtWidgets.QListWidgetItem()
        list_item.setSizeHint(QtCore.QSize(90,75))
        self.ui.list_textures.addItem(list_item)
        
        widget = List_Item_Widget(filepath)
        self.ui.list_textures.setItemWidget(list_item, widget)

        widget.ui.texture_type.currentIndexChanged.connect(lambda new_value=widget.ui.texture_type.currentText(): self.update_maps(widget, new_value))
  
    
    def info_clean(self):
        self.ui.label_info.setText("")
        self.ui.label_info.setStyleSheet("")
    
    def info_display_error(self, error_message):
        self.ui.label_info.setText(error_message)
        self.ui.label_info.setStyleSheet("color:#fc979a;")
        
    def generate_setup(self):
        network_editor = hou.ui.paneTabOfType(hou.paneTabType.NetworkEditor)
        stage = network_editor.pwd()
    
        self.info_clean()
        
        if self.validate_item_types() == False:
            self.info_display_error("Some textures don't have their type assigned. Aborting.")
            return
        
        if self.ui.cb_wipe_network.isChecked() == True:
            self.wipe_network(stage)
        
        collect = stage.createNode("collect")
        
        
        for engine in lookup.keys():
            engine_checkbox = getattr(self.ui, lookup[engine]["engine_enable_checkbox"], None) 
            
            if engine_checkbox.isChecked() == True:            
                subnet = stage.createNode("subnet")
                self.process_node_recursive(subnet, lookup[engine]["nodes"]["children"][0], subnet.node("suboutput1"))
                subnet.layoutChildren()

        stage.layoutChildren()
            
    def get_path_by_type(self, desired_type):
        
        desired_type_num = -1
    
        for key, value in type_lookup.items():
            if value == desired_type:
                desired_type_num = key
        
        for index in range(self.ui.list_textures.count()):
            item = self.ui.list_textures.item(index)
            item_widget = self.ui.list_textures.itemWidget(item)
            combo_box = item_widget.ui.texture_type 
            
            if combo_box.currentIndex() == desired_type_num:
                return item_widget.path
        return None
    
    def is_condition_met(self, condition):
        if "ui_checkbox" in condition:
            checkbox = getattr(self.ui, condition["ui_checkbox"], None)
            if "value" in condition:
                value = condition["value"]
                
                if checkbox.isChecked()  == value:
                    return True
                else:
                    return False
        
    def process_node_recursive(self, subnet, json_object, parent=None):
        """
        Recursively creates nodes from an object in a json file.
        """
        if "condition" not in json_object or "condition" in json_object and self.is_condition_met(json_object["condition"]):
             
            if 'map' in json_object:
                
                map = json_object['map']
                path = self.get_path_by_type(map)
                
                if path != None:
                    node = subnet.createNode(json_object['type'])
                    
                    # connect to parent
                    if parent != None and "connect_to" in json_object:
                        parent.setInput(json_object["connect_to"], node)
                    
                    # set parameters
                    if 'parms' in json_object:
                        for key, value in json_object['parms'].items():
                            if "{{path}}" in value:
                                json_object['parms'][key] = path
                                
                        node.setParms(json_object['parms'])
                        
                    #connect to parent
                    if parent != None and "connect_to" in json_object:
                        parent.setInput(json_object["connect_to"], node)
                        
                    for child_node in json_object.get("children", []):
                        self.process_node_recursive(subnet, child_node, node)
                else:
                    # skip this node and continue recursion
                    for child_node in json_object.get("children", []):
                        self.process_node_recursive(subnet, child_node, parent)
            
            else:
                node = subnet.createNode(json_object['type'])
                
                if 'parms' in json_object:
                    node.setParms(json_object['parms'])
                
                #connect to parent
                if parent != None and "connect_to" in json_object:
                    parent.setInput(json_object["connect_to"], node)
                    
                for child_node in json_object.get("children", []):
                    self.process_node_recursive(subnet, child_node, node)
        else:
            # skip this node and continue recursion
            for child_node in json_object.get("children", []):
                self.process_node_recursive(subnet, child_node, parent)
            

    def get_item_widget(self, index):
        item = self.ui.list_textures.item(index)
        widget = self.ui.list_textures.itemWidget(item)
        return widget
                    
    def validate_item_types(self):
        """
        Checks if all textures have an assigned type.
        """
        for index in range(self.ui.list_textures.count()):
            item = self.ui.list_textures.item(index)
            widget = self.ui.list_textures.itemWidget(item)
            
            if widget.ui.texture_type.currentIndex() == -1:
                return False
        return True
        
    def is_there_opacity_map(self):
        for index in range(self.ui.list_textures.count()):
            item = self.ui.list_textures.item(index)
            widget = self.ui.list_textures.itemWidget(item)
            
            if widget.ui.texture_type.currentIndex() == opacity_index:
                return True
        return False
         

    
    def wipe_network(self, network):
        for child_node in network.children():
            child_node.destroy()


class List_Item_Widget(QtWidgets.QWidget):
    def __init__(self, filepath, parent=None):
        super().__init__(parent)
        ui_file = hou.expandString('$AMMATBUILD/list_item.ui')
        self.ui = QtUiTools.QUiLoader().load(ui_file, parentWidget=self)
        
        layout = QtWidgets.QVBoxLayout()
        layout.setContentsMargins(0, 0, 0, 0)
        self.setLayout(layout)
        layout.addWidget(self.ui)
        
        
        self.path = filepath
        
        resolved_path = hou.expandString(filepath)
        file_name = os.path.basename(resolved_path)
        
        
        self.ui.file_path.setText(file_name)
        self.ui.file_path.setToolTip(file_name)
        
        type = self.detect_texture_type(file_name)
        self.ui.texture_type.setCurrentIndex(type)
        
        self.ui.btn_destroy.clicked.connect(self.destroy)
        

        
    def detect_texture_type(self, file_name):
        file_name = file_name.lower()
        
        base_color_names = ["color", "diff", "albedo"]
        opacity_names = ["opacity", "alpha", "transparency"]
        height_names = ["displace", "height"]
  
        if "nor" in file_name:
            return 3
        elif "metal" in file_name:
            return 1
        elif "rough" in file_name:
            return 2
        elif "bump" in file_name:
            return 5
        elif "emission" in file_name:
            return 7
        
        for name in base_color_names:
            if name.lower() in file_name:
                return 0
                
        for name in opacity_names:
            if name.lower() in file_name:
                return 6
                
        for name in height_names:
            if name.lower() in file_name:
                return 4
        
        
            
        return -1
        
    def destroy(self):
        list = self.parent().parent()
        items = list.findItems("", QtCore.Qt.MatchContains)
           
        for item in items:
            if list.itemWidget(item) == self:
                list.takeItem(list.row(item))
                break
        
        list.parent().parent().paths_list.remove(self.path)

        

        
    
win = MaterialCreator()
win.show()





            
            
        
        # for engine in lookup.keys():
        #     engine_checkbox = getattr(self.ui, lookup[engine]["checkbox"], None) 
            
        #     if engine_checkbox.isChecked() == True:
        #         main_node = stage.createNode(lookup[engine]["main_node"])
        #         main_node.setGenericFlag(hou.nodeFlag.Material, False)
                
        #         last_node = main_node
           
        #         for intermediary_node in lookup[engine]["material_intermediary_nodes"]:
        #             if intermediary_node == 'redshift::Sprite':
        #                 if self.ui.cb_enablerssprite.isChecked() == False:
        #                     continue
        #                 elif self.is_there_opacity_map() == False:
        #                     continue
        #             inter_node = stage.createNode(intermediary_node)
        #             inter_node.setGenericFlag(hou.nodeFlag.Material, False)
        #             self.redshift_output = inter_node
        #             inter_node.setInput(0, last_node)
        #             last_node = inter_node
                    
        #         collect.setInput(self.input_index, last_node)
        #         self.input_index += 1
                
                    
        #         for index in range(self.ui.list_textures.count()):
        #             widget = self.get_item_widget(index)
                    
        #             type = type_lookup[widget.ui.texture_type.currentIndex()]
                    
        #             file_path = widget.path
                    
        #             self.create_image_node(stage, engine, collect, main_node, type, file_path)
              
        # stage.layoutChildren()
        # self.input_index = 0
        
        
        
        
        
        
        
            # def create_image_node(self, stage, engine, collect, main_node, type, file_path):
    #     img_node = stage.createNode(lookup[engine]["image_node"])
        
    #     img_parm = lookup[engine]["image_parms"]
        
    #     img_node.parm(img_parm["type"]).set(img_parm["mode"][type])
    #     img_node.parm(img_parm["filepath"]).set(file_path)
        
        
    #     if type in lookup[engine]["image_intermediary_nodes"]:
    #         intermediary_dict = lookup[engine]["image_intermediary_nodes"][type]
    #         node_to_create = intermediary_dict["node"]
    #         input_index = intermediary_dict["input"]
    #         parms_to_change = intermediary_dict["parms_to_change"]
    #         connect_target = intermediary_dict["target"]
            
    #         intermediary = stage.createNode(node_to_create)
    #         intermediary.setGenericFlag(hou.nodeFlag.Material, False)
    #         intermediary.setInput(input_index, img_node)
    #         intermediary.setParms(parms_to_change)
            
    #         if connect_target == "main_node":
    #             main_node.setInput(lookup[engine]["main_inputs"][type], intermediary)
    #         elif connect_target == "intermediary_output":
    #             self.redshift_output.setInput(1, intermediary)
    #         elif connect_target == "collect":
    #             collect.setInput(self.input_index, intermediary)
    #             self.input_index += 1
                
    #     else:
    #         main_node.setInput(lookup[engine]["main_inputs"][type], img_node)]]></script>
  </tool>
</shelfDocument>
